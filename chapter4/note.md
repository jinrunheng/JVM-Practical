## 第四章 内存分配

#### 4-1 JVM的简化架构和运行时数据区

JVM的简化架构示意图如下：

<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmtc2fsjh3j312u0ry78g.jpg" alt="image-20210119213828468" style="zoom:50%;" align="left"/>

##### 运行时数据区域

- PC寄存器(程序计数器)
- Java虚拟机栈
- Java堆
- 方法区
- 运行时常量池
- 本地方法栈
- ... ...

##### PC寄存器

PC寄存器(Program Counter)说明：

1. 每个线程拥有一个PC寄存器，是线程私有的，用来存储指向下一条指令的地址
2. 在创建线程的时候，创建相应的PC寄存器
3. 执行本地方法时，PC寄存器的值为`undefined`
4. PC寄存器是一块小的内存空间，是唯一一个在JVM规范中没有规定`OutOfMemoryError`的内存区域

##### Java栈

1. 栈由一系列帧(Frame)组成，它是线程私有的
2. 帧用来保存一个方法的局部变量，操作数栈(Java没有寄存器，所有参数传递使用操作数栈)，常量池指针，动态链接，方法返回值等
3. 每一次方法调用创建一个帧，并压栈，退出方法的时候，修改栈顶之后真就可以把栈帧中的内容销毁
4. 局部变量表存放了编译期可知的各种基本数据类型和引用类型，每个`slot`存放32位的数据，`long`,`double`占两个槽位
5. 栈的优点：存取速度比堆快，仅次于寄存器
6. 栈的缺点：存在栈中的数据大小，生存期是在编译期决定的，缺乏灵活性

##### Java堆

1. 用来存放应用系统创建的对象和数组，所有线程共享Java堆
2. GC主要就管理堆空间，对分代GC来说，堆也是分代的
3. 堆的优点：运行期动态分配内存大小，自动进行垃圾回收
4. 堆的缺点：效率相对较慢

##### 方法区

1. 方法区是线程共享的，通常用来保存装载类的结构信息
2. 通常和元空间关联在一起，但具体的跟JVM实现和版本有关
3. JVM规范把方法区描述为堆的一个逻辑部分，但它有一个别称`Non-heap`(非堆),应是为了与Java堆区分开

##### 运行时常量池

1. 是`Class`文件中每个类或接口的常量池表，在运行期间的表示形式，通常包括：类的版本，字段，方法，接口等信息
2. 在方法区中分配
3. 通常在加载类和接口到JVM，就创建相应的运行时常量池

##### 本地方法栈

1. 在JVM中用来支持`native`方法执行的栈就是本地方法栈

##### 栈，堆，方法区交互关系

<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmtd97y1n4j31d00jydju.jpg" alt="image-20210119221929252" style="zoom: 33%;" align="left"/>

#### 4-2 Java堆内存模型和分配

##### Java堆内存概述

- Java堆用来存放应用系统创建的对象和数组，所有线程共享Java堆
- Java堆是在运行期动态分配内存大小，自动进行垃圾回收
- Java垃圾回收(GC)主要就是用来回收堆内存的，对分代GC来说，堆也是分代的

##### Java堆的结构

heap区分为：

- Eden Space（伊甸园）
- Survivor Space（幸存者区）
- Old Gen（老年代）

示例图如下：

<img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmtdprhysfj317e0n0acu.jpg" alt="image-20210119223526103" style="zoom:50%;" align="left"/>

##### 关于Java堆

- 新生代用来放新分配的对象；新生代中经过垃圾回收，没有回收掉的对象，（从To Space）被复制到老年代
- 老年代存储对象比新生代存储对象的年龄大得多
- 老年代存储一些大对象
- 整个堆的大小 = 新生代 + 老年代
- 新生代 = Eden + 存活区(To Space和From Space只能用一块)
- 从前的持久代，用来存放Class，Method等元信息的区域，从JDK8开始去掉了，取而代之的是元空间(Meta Space)。元空间并不在虚拟机里面，而是直接使用本地内存

##### 对象的内存布局

- 对象在内存中存储的布局（以HotSpot虚拟机为例说明），分为：对象头，实例数据和对齐填充
- 对象头，包含两个部分：
  - Mark Word：存储对象自身的运行数据，如：HashCode，GC分代年龄，锁状态标志等
  - 类型指针：对象指向它的类元数据的指针
- 实例数据：真正存放对象实例数据的地方
- 对齐填充：这部分不一定存在，也没有什么特别含义，仅仅是占位符。因为HotSpot要求对象起始地址都是8字节的整数倍，如果不是就对齐

##### 对象的访问定位

- 对象的访问定位

  在JVM规范中只规定了reference类型是一个指向对象的引用，但没有规定这个引用具体如何去定位，访问堆中对象的具体位置

- 因此对象的访问方式取决于JVM的实现，目前主流的有：使用句柄 或 使用指针 两种方式

- 使用句柄：

  Java堆中会划分出一块内存来作为句柄池，reference中存储句柄的地址，句柄中存储对象的实例数据和类元数据的地址

  如下图：

  <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmte8xlb5lj30wy0j8n4m.jpg" alt="image-20210119225353731" style="zoom:33%;" align="left"/>

- 使用指针：

  Java堆中会存放访问类元数据的地址，reference存储的就直接是对象的地址，如下图所示：

  <img src="https://tva1.sinaimg.cn/large/008eGmZEgy1gmteayznegj30yq0fqqgc.jpg" alt="image-20210119225550559" style="zoom:33%;" align="left"/>

- 通过句柄访问对象是一种间接引用(2次引用)的方式来进行访问堆内存的对象，它导致的缺点是运行的速度稍微慢一些；通过指针的方式则速度快一些，因为它少了一次指针定位的开销，所以HotSpot采用的就是指针的方式

#### 4-3 Trace跟踪和Java堆的参数配置

#### 4-4 新生代配置和GC日志格式

#### 4-5 案例：使用MAT进行内存分析

#### 4-6 案例：堆，栈，元空间的参数配置

